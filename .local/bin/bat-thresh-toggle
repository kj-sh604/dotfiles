#!/bin/sh

THRESH_START_PATH="/sys/class/power_supply/BAT0/charge_control_start_threshold"
THRESH_STOP_PATH="/sys/class/power_supply/BAT0/charge_control_end_threshold"
TLP_DROP_IN="/etc/tlp.d/05-bat-thresh.conf"

DOCKED_START=80
DOCKED_STOP=90
DEFAULT_START=96
DEFAULT_STOP=100

usage() {
    cat <<EOF
usage: $(basename "$0") [OPTION]

toggles BAT0 charge thresholds between docked and default modes,
writing or removing a persistent TLP drop-in at ${TLP_DROP_IN}.

options:
  -h, --help         show this help message and exit

modes:
  docked            START_CHARGE_THRESH_BAT0=${DOCKED_START}    STOP_CHARGE_THRESH_BAT0=${DOCKED_STOP}
  default           START_CHARGE_THRESH_BAT0=${DEFAULT_START}   STOP_CHARGE_THRESH_BAT0=${DEFAULT_STOP}

EOF
}

case "${1}" in
    -h|--help) usage; exit 0 ;;
esac

# gotta be root to write to sysfs
if [ "$(id -u)" -ne 0 ]; then
    usage
    sleep 1
    echo "error: script must be run as root."; echo ""
    exit 1
fi

# make sure the sysfs nodes are actually there
[ -f "$THRESH_START_PATH" ] || { echo "error: $THRESH_START_PATH not found — is thinkpad_acpi loaded?"; exit 1; }
[ -f "$THRESH_STOP_PATH" ]  || { echo "error: $THRESH_STOP_PATH not found — is thinkpad_acpi loaded?"; exit 1; }

current_stop=$(cat "$THRESH_STOP_PATH")

# determine which mode to switch INTO based on the current stop threshold
case "$current_stop" in
    "$DOCKED_STOP")
        target_mode="default"
        new_start="$DEFAULT_START"
        new_stop="$DEFAULT_STOP"
        ;;
    *)
        target_mode="docked"
        new_start="$DOCKED_START"
        new_stop="$DOCKED_STOP"
        ;;
esac

# the kernel enforces start < stop at all times, so write order matters
case "$target_mode" in
    default)
        printf "%s" "$new_stop"  > "$THRESH_STOP_PATH"  || { echo "error: failed to write stop threshold.";  exit 1; }
        printf "%s" "$new_start" > "$THRESH_START_PATH" || { echo "error: failed to write start threshold."; exit 1; }
        ;;
    docked)
        printf "%s" "$new_start" > "$THRESH_START_PATH" || { echo "error: failed to write start threshold."; exit 1; }
        printf "%s" "$new_stop"  > "$THRESH_STOP_PATH"  || { echo "error: failed to write stop threshold.";  exit 1; }
        ;;
esac

echo "switched to $target_mode mode — start: ${new_start}%  stop: ${new_stop}%"

# write or remove drop-in so thresholds survive a reboot; no sed fragility
if [ -d "/etc/tlp.d" ]; then
    case "$target_mode" in
        docked)
            printf '# managed by bat-thresh-toggle — do not edit by hand\nSTART_CHARGE_THRESH_BAT0=%s\nSTOP_CHARGE_THRESH_BAT0=%s\n' \
                "$new_start" "$new_stop" > "$TLP_DROP_IN" \
                && echo "${TLP_DROP_IN} written" \
                || echo "error: failed to write ${TLP_DROP_IN}."
            ;;
        default)
            if [ -f "$TLP_DROP_IN" ]; then
                rm "$TLP_DROP_IN" \
                    && echo "${TLP_DROP_IN} removed — TLP will use its built-in defaults after reboot." \
                    || echo "error: failed to remove ${TLP_DROP_IN}."
            fi
            ;;
    esac
else
    echo "note: /etc/tlp.d not found - sysfs write is not persistent across reboots."
fi
